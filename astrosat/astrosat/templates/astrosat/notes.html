{# index.html #}

{% extends "astrosat/base.html" %}

{% load staticfiles %}

{% block content %}

    <div class="title">Here are some useful notes:</div>

    <div class="panel-group" id="accordion" role="tablist" aria-multiselectable="true">
      <div class="panel panel-default">
        <div class="panel-heading" role="tab" id="heading-01">
          <h4 class="panel-title">
            <a role="button" data-toggle="collapse" data-parent="#accordion" href="#collapse-01" aria-expanded="true" aria-controls="collapse-01">
              Isn't this a bit overkill?
            </a>
          </h4>
        </div>
        <div id="collapse-01" class="panel-collapse collapse" role="tabpanel" aria-labelledby="heading-01">
          <div class="panel-body">
            <p>
              Well, <em>maybe</em>.  But a lot of it is boilerplate code that I use for all of my Django projects.  This includes the following things:
              <ul>
                <li>an external configuration file</li>
                <li>custom context processors</li>
                <li>custom middleware (dynamic sites)</li>
                <li>compression & pre-compiling static files</li>
                <li>clever integration of Django & AngularJS</li>
              </ul>
            </p>
          </div>
        </div>
      </div>
      <div class="panel panel-default">
        <div class="panel-heading" role="tab" id="heading-02">
          <h4 class="panel-title">
            <a class="collapsed" role="button" data-toggle="collapse" data-parent="#accordion" href="#collapse-02" aria-expanded="false" aria-controls="collapse-02">
              How is data imported?
            </a>
          </h4>
        </div>
        <div id="collapse-02" class="panel-collapse collapse" role="tabpanel" aria-labelledby="heading-02">
          <div class="panel-body">
            <p>
              This is a bit convoluted.
            </p>
            <p>
              Originally, I used a "service" which retrieved the data published by NASA and sent it as a "signal" to a handler which did the actual ingestion work.
              Now I use an explicit "task" which performs all of those tasks together on a schedule defined by <code>celery</code>.
            </p>
            <p>
              That task, however, can still be run outside of the schedule via a service using the view at "astrosat/views/services/views_services_facilities".
              This is bound to some AngularJS code on the index page.
            </p>
          </div>
        </div>
      </div>
      <div class="panel panel-default">
        <div class="panel-heading" role="tab" id="heading-03">
          <h4 class="panel-title">
            <a class="collapsed" role="button" data-toggle="collapse" data-parent="#accordion" href="#collapse-03" aria-expanded="false" aria-controls="collapse-03">
                Editing existing facilities via the Django Admin Console
            </a>
          </h4>
        </div>
        <div id="collapse-03" class="panel-collapse collapse" role="tabpanel" aria-labelledby="heading-03">
          <div class="panel-body">
            <p>
                Django does most of this for you simply by registering a <code>ModelAdmin</code> class with the <code>Facility</code> class (see "astrosat/admin/admin_facilitiespy").
            </p>
            <p>
                The spec states that I should prevent users from deleting or adding Facilities.  This was simple to do by overriding the <code>has_add_permission</code> and <code>has_delete_permission</code> from the <code>FacilityAdmin</code> class.
                In addition, I had to disable the <code>delete_selected</code> action available in batch-editing mode. Rather than set the actions of <code>FacilityAdmin</code> to None, as suggested in the Django documentation, I overrode the <code>get_actions</code> method to explicitly remove just that action, in case others were added at some future date.
            </p>
            <p>
              Only Admin users should be able to edit facilities.
              Obviously, if they navigate directly to the Admin Console unauthenticated users will be prompted to login and everything will work as above.
              However, on the "index" page I explicitly disable the link to the Admin Console by passing a template context variable and binding it to a variable in the AngularJS Controller associated with that page.
              That variable is used to conditionally apply a class which makes it no longer look like a link, and the function <code>disable_event</code> in "astrosat/static/astrosat/scripts/ng_index.js" potentially disables the click event.
            </p>
          </div>
        </div>
      </div>
      <div class="panel panel-default">
        <div class="panel-heading" role="tab" id="heading-04">
          <h4 class="panel-title">
            <a class="collapsed" role="button" data-toggle="collapse" data-parent="#accordion" href="#collapse-04" aria-expanded="false" aria-controls="collapse-04">
                API endpoint to service the facilities data in JSON format
            </a>
          </h4>
        </div>
        <div id="collapse-04" class="panel-collapse collapse" role="tabpanel" aria-labelledby="heading-04">
          <div class="panel-body">
            <p>
              This was pretty easy by using Django-Rest-Framework.
              I've used it before and, unless your application is very straightforward, I would recommend using it to provide a RESTful interface for JSON data on the backend and something like Angular or another JavaScript framework on the frontend.
            </p>
            <p>
              The "raw JSON" link provided on the index page returns pure JSON as requested.  The "DRF API" link serves the data with pretty Django-Rest-Framework styling.
              I turned off paging for that particular view just so that I can easily get the <em>full set</em> of <code>Facility</code> serializations when loading content into the AngularJS Controller for the "index" page.
            </p>
            <p>
              I've setup a serializer for my implementation of the <code>Facility</code> class.
              This is defined in "astrosat/serializers/serializers_facilities.py".
              It does nothing fancy - it just includes all fields.
              I don't need to worry about overriding <code>create</code> or <code>update</code>, since the spec indicates that I should use the Django Admin Console to update Facilties.
              Note that I do still use the <code>update</code> functionality for importing data into the database, but that is not exposed by the Django-Rest-Framework views.
              Those views are defined in "astrosat/views/api/views_api_facilities" (and bound to URLS in "astrosat/urls.py").
              Rather than write a custom permission class, I can just base my ViewSet off of <code>ReadOnlyModelViewSet</code>.
            </p>
            <p>
              The spec also states that I should only serve "active" facilities.  This is done by using a custom object manager for Facilities which defines "active" and "inactive" QuerySets.
              You can see that the active queryset is used with the <code>FacilityViewSet</code>.
            </p>
          </div>
        </div>
      </div>
      <div class="panel panel-default">
        <div class="panel-heading" role="tab" id="heading-05">
          <h4 class="panel-title">
            <a class="collapsed" role="button" data-toggle="collapse" data-parent="#accordion" href="#collapse-05" aria-expanded="false" aria-controls="collapse-05">
                What haven't I done (<em>yet</em>)?
            </a>
          </h4>
        </div>
        <div id="collapse-05" class="panel-collapse collapse" role="tabpanel" aria-labelledby="heading-05">
          <div class="panel-body">
            <p>
              This was only meant to take ~4 hours.  So, I didn't complete everything I would have for a production-level website.
              Hopefully, there is enough here to prove that I know how to code in general and how to use Django in particular.
            </p>
            <p>
              Here are the glaring omissions:
              <ul>
                <li>location field on facility class</li>
                <li>celery should probably be run as a service, but I didn't want to make any presumptions about your deploy environment</li>
                <li>full test coverage</li>
                <li>"hacky" install script</li>
                <li>
                  Tt's not <em>really</em> production because if it were I would serve static files outside of the Django Project.
                  In fact, setting <code>debug</code> to False will cause loading </li> local static files to fail.
                  However, I <em>do</em> want to run with <code>debug</code> set to False so that my custom error views ("astrosat/views/views_errors.py") will run.
                  In order to get around this catch-22, I just run the server with <code>python astrosat/manage.py runserver --insecure</code>.
              </ul>
            </p>
          </div>
        </div>
      </div>
    </div>

{% endblock %}  {# /content #}
